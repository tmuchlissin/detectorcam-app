import os
import threading
import cv2
import time
import logging
import queue
import sys
from ultralytics import YOLO
import tempfile

# Setup logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(threadName)s - %(levelname)s - %(message)s')

# File handler untuk menulis ke detector.log
file_handler = logging.FileHandler('detector.log')
file_handler.setFormatter(formatter)
logger.addHandler(file_handler)

# Stream handler untuk menulis ke terminal
stream_handler = logging.StreamHandler(sys.stdout)
stream_handler.setFormatter(formatter)
logger.addHandler(stream_handler)

# Shared queue for notifications (if needed in the future)
message_queue = queue.Queue()

# Store annotated frames for detector streaming
annotated_frames = {}


class CameraStreamManager:
    def __init__(self):
        self.camera_streams = {}
        self.lock = threading.Lock()

    def get_camera_stream(self, ip_address):
        from app.models import Camera
        with self.lock:
            # Check if camera is active in database
            camera = Camera.query.filter_by(ip_address=ip_address).first()
            if not camera or not camera.status:
                logger.warning(f"Camera with IP {ip_address} is not active or does not exist.")
                return None
                
            if ip_address not in self.camera_streams:
                logger.info(f"Starting new camera stream for IP: {ip_address}")
                camera_stream = CameraStream(ip_address)
                camera_stream.start()
                self.camera_streams[ip_address] = camera_stream
            else:
                # Check if existing stream is healthy
                existing_stream = self.camera_streams[ip_address]
                if not existing_stream.is_healthy():
                    logger.warning(f"Existing stream for {ip_address} is unhealthy, restarting...")
                    existing_stream.stop()
                    if existing_stream.is_alive():
                        existing_stream.join(timeout=5)  # Wait max 5 seconds
                    
                    # Create new stream
                    camera_stream = CameraStream(ip_address)
                    camera_stream.start()
                    self.camera_streams[ip_address] = camera_stream
                    
            return self.camera_streams[ip_address]

    def stop_inactive_streams(self):
        from app.models import Camera
        with self.lock:
            logger.info("Checking for inactive camera streams.")
            for ip_address in list(self.camera_streams.keys()):
                camera = Camera.query.filter_by(ip_address=ip_address).first()
                if not camera or not camera.status:
                    logger.info(f"Stopping inactive camera stream for IP: {ip_address}")
                    stream = self.camera_streams[ip_address]
                    stream.stop()
                    
                    # Wait for thread to finish, but don't block indefinitely
                    if stream.is_alive():
                        stream.join(timeout=10)
                        if stream.is_alive():
                            logger.warning(f"Camera stream thread for {ip_address} did not stop gracefully")
                    
                    del self.camera_streams[ip_address]

    def stop_all(self):
        with self.lock:
            logger.info("Stopping all camera streams.")
            for ip_address, camera_stream in list(self.camera_streams.items()):
                camera_stream.stop()
                if camera_stream.is_alive():
                    camera_stream.join(timeout=10)
                    if camera_stream.is_alive():
                        logger.warning(f"Camera stream thread for {ip_address} did not stop gracefully")
            self.camera_streams.clear()

    def cleanup_dead_streams(self):
        """Remove dead camera streams from the manager"""
        with self.lock:
            dead_streams = []
            for ip_address, stream in self.camera_streams.items():
                if not stream.is_alive() or not stream.is_healthy():
                    dead_streams.append(ip_address)
            
            for ip_address in dead_streams:
                logger.info(f"Cleaning up dead stream for IP: {ip_address}")
                try:
                    self.camera_streams[ip_address].stop()
                except Exception as e:
                    logger.warning(f"Error stopping dead stream {ip_address}: {e}")
                finally:
                    del self.camera_streams[ip_address]

class CameraStream(threading.Thread):
    def __init__(self, ip_address):
        super().__init__(name=f"CameraStream-{ip_address}")
        self.ip_address = ip_address
        self.capture = None
        self.frame = None
        self.running = True
        self.lock = threading.Lock()
        self.connection_failed = False
        self._initialize_capture()
        logger.info(f"Initialized CameraStream for IP: {self.ip_address}")

    def _initialize_capture(self):
        """Initialize the video capture with proper error handling"""
        try:
            if self.ip_address == 'http://1.1.1.1':
                self.capture = cv2.VideoCapture(0)
            else:
                self.capture = cv2.VideoCapture(self.ip_address)
            
            if self.capture is not None:
                self.capture.set(cv2.CAP_PROP_FPS, 30)
                # Set buffer size to prevent frame accumulation
                self.capture.set(cv2.CAP_PROP_BUFFERSIZE, 1)
                
            if not self.capture.isOpened():
                logger.error(f"Failed to open camera stream for IP: {self.ip_address}")
                self.connection_failed = True
        except Exception as e:
            logger.error(f"Exception while initializing camera {self.ip_address}: {e}")
            self.connection_failed = True

    def run(self):
        logger.info(f"Camera stream started for IP: {self.ip_address}")
        consecutive_failures = 0
        max_consecutive_failures = 10
        
        while self.running:
            if self.connection_failed or not self.capture or not self.capture.isOpened():
                if consecutive_failures < max_consecutive_failures:
                    logger.warning(f"Attempting to reconnect to {self.ip_address}")
                    self._reconnect()
                    consecutive_failures += 1
                    time.sleep(2)
                    continue
                else:
                    logger.error(f"Max reconnection attempts reached for {self.ip_address}")
                    break
            
            try:
                ret, frame = self.capture.read()
                if ret and frame is not None:
                    with self.lock:
                        self.frame = frame
                    consecutive_failures = 0  # Reset failure count on success
                else:
                    consecutive_failures += 1
                    logger.warning(f"Failed to read frame from IP: {self.ip_address} (attempt {consecutive_failures})")
                    
                    if consecutive_failures >= 3:  # Try reconnecting after 3 consecutive failures
                        self._reconnect()
                        time.sleep(1)
                    
            except Exception as e:
                logger.error(f"Exception while reading frame from {self.ip_address}: {e}")
                consecutive_failures += 1
                if consecutive_failures >= 3:
                    self._reconnect()
                time.sleep(1)
        
        logger.info(f"Camera stream thread ending for IP: {self.ip_address}")

    def _reconnect(self):
        """Safely reconnect to the camera stream"""
        if not self.running:
            return
            
        logger.info(f"Reconnecting to camera stream for IP: {self.ip_address}")
        
        # Safely release the current capture
        if self.capture is not None:
            try:
                self.capture.release()
            except Exception as e:
                logger.warning(f"Error releasing capture for {self.ip_address}: {e}")
            finally:
                self.capture = None
        
        time.sleep(2)  # Wait before reconnecting
        
        # Reinitialize capture
        self._initialize_capture()
        
        if self.connection_failed:
            logger.warning(f"Reconnection failed for IP: {self.ip_address}")
        else:
            logger.info(f"Successfully reconnected to IP: {self.ip_address}")

    def get_frame(self):
        with self.lock:
            return self.frame.copy() if self.frame is not None else None

    def stop(self):
        """Gracefully stop the camera stream"""
        logger.info(f"Stopping camera stream for IP: {self.ip_address}")
        self.running = False
        
        # Give the thread a moment to finish current operations
        time.sleep(0.1)
        
        if self.capture is not None:
            try:
                self.capture.release()
            except Exception as e:
                logger.warning(f"Error releasing capture during stop for {self.ip_address}: {e}")
            finally:
                self.capture = None
        
        logger.info(f"Camera stream stopped for IP: {self.ip_address}")

    def is_healthy(self):
        """Check if the camera stream is healthy"""
        return self.running and not self.connection_failed and self.capture is not None and self.capture.isOpened()

class DetectorThread(threading.Thread):
    def __init__(self, app, detector_id, camera_stream):
        super().__init__(name=f"DetectorThread-{detector_id}")
        self.app = app
        self.detector_id = detector_id
        self.camera_stream = camera_stream
        self.running = True
        self.lock = threading.Lock()
        self.yolo_model = None
        self.temp_model_file = None
        logger.info(f"Initialized DetectorThread for detector ID: {self.detector_id}")

    def _load_model_from_database(self):
        """Load YOLO model from database binary data"""
        try:
            from app.models import Detector, Model
            with self.app.app_context():
                detector = Detector.query.get(self.detector_id)
                if not detector:
                    logger.error(f"Detector not found for ID: {self.detector_id}")
                    return False
                
                model = Model.query.get(detector.model_id)
                if not model or not model.model_file:
                    logger.error(f"Model not found or model file is empty for detector ID: {self.detector_id}")
                    return False
                
                # Create temporary file for the model
                self.temp_model_file = tempfile.NamedTemporaryFile(suffix='.pt', delete=False)
                self.temp_model_file.write(model.model_file)
                self.temp_model_file.close()
                
                # Load YOLO model from temporary file
                self.yolo_model = YOLO(self.temp_model_file.name)
                logger.info(f"Successfully loaded model {model.model_name} for detector ID: {self.detector_id}")
                return True
                
        except Exception as e:
            logger.error(f"Error loading model for detector ID: {self.detector_id}: {e}")
            return False

    def run(self):
        logger.info(f"DetectorThread started for detector ID: {self.detector_id}")
        
        # Load model from database
        if not self._load_model_from_database():
            logger.error(f"Failed to load model for detector ID: {self.detector_id}")
            return
        
        frame_count = 0
        
        while self.running:
            try:
                # Check if detector is still active every 30 frames (~1 second at 30fps)
                if frame_count % 30 == 0:
                    with self.app.app_context():
                        from app.models import Detector, Camera
                        current_detector = Detector.query.get(self.detector_id)
                        if not current_detector or not current_detector.running:
                            logger.info(f"Detector {self.detector_id} became inactive, stopping thread")
                            break
                        
                        current_camera = Camera.query.get(current_detector.camera_id)
                        if not current_camera or not current_camera.status:
                            logger.info(f"Camera for detector {self.detector_id} became inactive, stopping thread")
                            break
                
                if self.camera_stream is None:
                    logger.warning(f"No camera stream available for detector ID: {self.detector_id}")
                    time.sleep(1)
                    continue
                
                # Get frame from camera stream
                frame = self.camera_stream.get_frame()
                if frame is not None:
                    try:
                        with self.lock:
                            # Run YOLO detection on the frame
                            results = self.yolo_model(frame, verbose=False)  # verbose=False to reduce log spam
                            
                            # Get annotated frame with bounding boxes
                            annotated_frame = results[0].plot(
                                conf=True,  # Show confidence scores
                                labels=True,  # Show class labels
                                boxes=True,  # Show bounding boxes
                                line_width=2,  # Line thickness
                                font_size=12  # Font size for labels
                            )
                            
                            # Store the annotated frame for streaming
                            annotated_frames[self.detector_id] = annotated_frame
                            
                            # Log detection results (optional, can be removed for performance)
                            if len(results[0].boxes) > 0:
                                detections = len(results[0].boxes)
                                logger.debug(f"Detector {self.detector_id}: Found {detections} objects")
                                
                    except Exception as e:
                        logger.error(f"Error processing frame for detector ID: {self.detector_id}: {e}")
                        # Continue running even if one frame fails
                        
                else:
                    logger.warning(f"No frame available for detector ID: {self.detector_id}")
                    time.sleep(0.1)  # Short sleep when no frame available
                
                frame_count += 1
                time.sleep(0.033)  # ~30 FPS (33ms delay)
                
            except Exception as e:
                logger.error(f"Unexpected error in detector thread {self.detector_id}: {e}")
                time.sleep(1)  # Longer sleep on unexpected errors
        
        logger.info(f"DetectorThread for detector ID: {self.detector_id} finished")

    def stop(self):
        self.running = False
        
        # Clean up temporary model file
        if self.temp_model_file and os.path.exists(self.temp_model_file.name):
            try:
                os.unlink(self.temp_model_file.name)
                logger.info(f"Cleaned up temporary model file for detector ID: {self.detector_id}")
            except Exception as e:
                logger.warning(f"Failed to clean up temporary model file: {e}")
        
        # Remove annotated frame from global dict
        if self.detector_id in annotated_frames:
            del annotated_frames[self.detector_id]
            
        logger.info(f"DetectorThread stopped for detector ID: {self.detector_id}")

    def join(self, timeout=None):
        """Override join to ensure proper cleanup"""
        super().join(timeout)
        # Additional cleanup if needed
        
class DetectorManager:
    def __init__(self):
        self.detectors = {}
        self.camera_manager = CameraStreamManager()
        self.lock = threading.Lock()
        self.app = None

    def initialize_detectors(self, app):
        """Initialize all active detectors from database"""
        self.app = app
        from app.models import Detector, Camera, Model
        
        with self.app.app_context():
            with self.lock:
                logger.info("Initializing detectors...")
                active_detectors = Detector.query.filter(Detector.running == True).all()
                
                for detector in active_detectors:
                    try:
                        # Validate camera
                        camera = Camera.query.get(detector.camera_id)
                        if not camera or not camera.status:
                            logger.warning(f"Camera {detector.camera_id} is not active or does not exist. Skipping detector {detector.id}")
                            continue
                        
                        # Validate model
                        model = Model.query.get(detector.model_id)
                        if not model or not model.model_file:
                            logger.warning(f"Model {detector.model_id} is not valid or has no model file. Skipping detector {detector.id}")
                            continue
                        
                        # Get camera stream
                        camera_stream = self.camera_manager.get_camera_stream(camera.ip_address)
                        if not camera_stream:
                            logger.warning(f"Cannot get camera stream for {camera.ip_address}. Skipping detector {detector.id}")
                            continue
                        
                        # Start detector thread
                        detector_thread = DetectorThread(self.app, detector.id, camera_stream)
                        detector_thread.start()
                        self.detectors[detector.id] = detector_thread
                        
                        logger.info(f"Detector {detector.id} started with camera stream {camera.ip_address} and model {model.model_name}")
                        
                    except Exception as e:
                        logger.error(f"Failed to initialize detector {detector.id}: {e}")
                        continue
                
                logger.info(f"Initialized {len(self.detectors)} detectors")

    def update_detectors(self):
        """Update detectors based on current database state"""
        if not self.app:
            logger.error("DetectorManager not initialized with app context")
            return
            
        from app.models import Detector, Camera, Model
        
        with self.app.app_context():
            with self.lock:
                logger.info("Updating detectors...")
                
                try:
                    # Get currently active detectors from database
                    active_detectors = Detector.query.filter(Detector.running == True).all()
                    active_detector_ids = {detector.id for detector in active_detectors}

                    # Stop detectors that are no longer active
                    detectors_to_stop = []
                    for detector_id in list(self.detectors.keys()):
                        if detector_id not in active_detector_ids:
                            detectors_to_stop.append(detector_id)
                    
                    for detector_id in detectors_to_stop:
                        logger.info(f"Stopping detector ID: {detector_id}")
                        try:
                            self.detectors[detector_id].stop()
                            # Don't wait too long for thread to finish
                            self.detectors[detector_id].join(timeout=5.0)
                            del self.detectors[detector_id]
                            logger.info(f"Successfully stopped detector ID: {detector_id}")
                        except Exception as e:
                            logger.error(f"Error stopping detector {detector_id}: {e}")

                    # Start new detectors
                    for detector in active_detectors:
                        if detector.id not in self.detectors:
                            try:
                                # Validate camera
                                camera = Camera.query.get(detector.camera_id)
                                if not camera or not camera.status:
                                    logger.warning(f"Camera {detector.camera_id} is not active. Cannot start detector {detector.id}")
                                    continue
                                
                                # Validate model
                                model = Model.query.get(detector.model_id)
                                if not model or not model.model_file:
                                    logger.warning(f"Model {detector.model_id} is not valid. Cannot start detector {detector.id}")
                                    continue
                                
                                # Get camera stream
                                camera_stream = self.camera_manager.get_camera_stream(camera.ip_address)
                                if not camera_stream:
                                    logger.warning(f"Cannot get camera stream for {camera.ip_address}. Cannot start detector {detector.id}")
                                    continue
                                
                                # Start new detector thread
                                detector_thread = DetectorThread(self.app, detector.id, camera_stream)
                                detector_thread.start()
                                self.detectors[detector.id] = detector_thread
                                
                                logger.info(f"Started new detector ID: {detector.id} with camera {camera.ip_address} and model {model.model_name}")
                                
                            except Exception as e:
                                logger.error(f"Error starting new detector {detector.id}: {e}")
                                continue

                    # Clean up unused camera streams
                    self._cleanup_unused_camera_streams(active_detectors)
                    
                    logger.info(f"Detector update completed. Active detectors: {len(self.detectors)}")
                    
                except Exception as e:
                    logger.error(f"Error during detector update: {e}")

    def _cleanup_unused_camera_streams(self, active_detectors):
        """Stop camera streams that are no longer needed"""
        try:
            from app.models import Camera
            
            # Get IP addresses of cameras currently used by active detectors
            active_camera_ips = set()
            for detector in active_detectors:
                camera = Camera.query.get(detector.camera_id)
                if camera:
                    active_camera_ips.add(camera.ip_address)
            
            # Stop unused camera streams
            streams_to_stop = []
            for ip_address in list(self.camera_manager.camera_streams.keys()):
                if ip_address not in active_camera_ips:
                    streams_to_stop.append(ip_address)
            
            for ip_address in streams_to_stop:
                logger.info(f"Stopping unused camera stream for IP: {ip_address}")
                try:
                    self.camera_manager.camera_streams[ip_address].stop()
                    self.camera_manager.camera_streams[ip_address].join(timeout=5.0)
                    del self.camera_manager.camera_streams[ip_address]
                    logger.info(f"Successfully stopped camera stream for IP: {ip_address}")
                except Exception as e:
                    logger.error(f"Error stopping camera stream {ip_address}: {e}")
                    
        except Exception as e:
            logger.error(f"Error during camera stream cleanup: {e}")

    def stop_all(self):
        """Stop all detectors and camera streams"""
        with self.lock:
            logger.info("Stopping all detectors...")
            
            # Stop all detector threads
            for detector_id, detector_thread in list(self.detectors.items()):
                try:
                    logger.info(f"Stopping detector thread {detector_id}")
                    detector_thread.stop()
                    detector_thread.join(timeout=5.0)  # Wait max 5 seconds
                    logger.info(f"Stopped detector thread {detector_id}")
                except Exception as e:
                    logger.error(f"Error stopping detector thread {detector_id}: {e}")
            
            # Clear detectors dictionary
            self.detectors.clear()
            
            # Stop all camera streams
            try:
                self.camera_manager.stop_all()
            except Exception as e:
                logger.error(f"Error stopping camera streams: {e}")
            
            # Clear annotated frames
            global annotated_frames
            annotated_frames.clear()
            
            logger.info("All detectors and camera streams stopped.")

    def get_detector_status(self):
        """Get status of all running detectors"""
        with self.lock:
            status = {}
            for detector_id, detector_thread in self.detectors.items():
                status[detector_id] = {
                    'running': detector_thread.running,
                    'alive': detector_thread.is_alive(),
                    'has_frames': detector_id in annotated_frames
                }
            return status